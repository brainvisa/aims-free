<?xml version="1.0" encoding="iso8859-1"?>
<!DOCTYPE book
[
<!ENTITY % local.common.attrib "infoid CDATA #IMPLIED">
<!ATTLIST bookinfo code CDATA #REQUIRED>
]>


<book id='aims_pg%book'>
  <bookinfo code='aims_pg'>
    <date>Date de mise à jour : 02.11.2005</date>
    <title>Programmation AIMS</title>
  </bookinfo>
  <chapter id="aims_pg%chap1" infoid="pour le premier chapitre">

    <title>Utilisation des graphes</title>

    <para>Projets: graph, aims, cartobase, pyaims, [sigraph]</para>
    <para>Les exemples présentés sont compilables avec build-config et utilisables: ils sont dans le projet perforce <computeroutput>documents/main/coursGraphes-1005/examples/graphex-main</computeroutput>
    </para>

    <sect2>
      <title>Utilité</title>
      <para>en quoi c'est vachement générique: on peut mettre tout et n'importe quoi dedans, de façon "semi-structurée", sans qu'on ait à vraiment savoir ce qu'il y a dedans depuis les couches logicielles "génériques".
      </para>
      <para>ça aggrège un ensemble d'objets qu'on n'a pas à charger/manipuler/sauver un par un (par ex. on le charge dans anatomist en tant qu'un seul objet)
      </para>
      <para>ça sert à tout: ROIs, clusters, sillons, gyri, fibres, modèles de reconnaissance, primalsketches, modèles du monde
      </para>
    </sect2>

    <sect2>
      <title>Formats de fichiers</title>
      <para>fichier .arg [/ python-minf-like / XML], répertoire .data</para>
      <para>objets dans .data: objets Aims, sous forme "compacte" (global) ou "éclatée" (local)
      </para>
      <para>Le format .arg actuel a des limites (ou des garde-fou) dans sa généricité: la syntaxe, donnée par des
        fichiers externes.
      </para>
    </sect2>


    <sect2>
      <title>Pre-requis: librairie cartobase</title>

      <sect3>
        <title>Les compteurs de référence: <computeroutput>rc_ptr&lt;T&gt;</computeroutput></title>

        <para>C'est comme des pointeurs: ça s'utilise pareil:
          <programlisting>#include &lt;cartobase/smart/rcptr.h&gt;

{
  rc_ptr&lt;int&gt;  rc1( new int );
  rc_ptr&lt;int&gt;  rc2 = rc1;
  int a = *rc1 + *rc2;
}</programlisting>
        </para>
        <para>Les compteurs de référence se partagent l'appartenance d'un objet et le
          détruisent quand il n'y en a plus besoin:
        </para>
        <para>
          <emphasis role="bold">on ne doit jamais faire de <computeroutput>delete</computeroutput> sur l'objet pointé</emphasis>: ça se
          fait tout seul.
        </para>
      </sect3>


      <sect3>
        <title>Les objets génériques (cartobase)</title>

        <para><ulink url="#doxycartob%classcarto_1_1GenericObject"><computeroutput>GenericObject</computeroutput></ulink> est la classe de base pour tous les objets graphe, noeuds et relation.
        </para>
        <para>Un objet générique particulier super-courant: le dictionnaire: il contient un <computeroutput>Dictionary</computeroutput> (qui est un <computeroutput>typedef</computeroutput> sur <computeroutput>map&lt;string,Object&gt;</computeroutput>), ou un <computeroutput>PropertySet</computeroutput> qui est un truc maison équivalent à la base (mais avec d'autres trucs en plus).
        </para>
        <para>Fonctions génériques (<ulink url="#doxycartob%classcarto_1_1Interface"><computeroutput>Interface</computeroutput></ulink>):
          <itemizedlist>
            <listitem><computeroutput>getProperty</computeroutput>
            </listitem>
            <listitem><computeroutput>setProperty</computeroutput>
            </listitem>
            <listitem>itération sur les propriétés</listitem>
          </itemizedlist>
        </para>
        <para><computeroutput>Object</computeroutput> est un compteur de référence sur un <computeroutput>GenericObject</computeroutput>:
          on utilise surtout son opérateur <computeroutput>-&gt;</computeroutput>.
        </para>
      </sect3>
    </sect2>


    <sect2>
      <title>Clases principales</title>

      <itemizedlist>
        <listitem>
          <ulink url="#doxygraph%classGraph"><computeroutput>Graph</computeroutput></ulink>
        </listitem>

        <listitem>
          <ulink url="#doxygraph%classVertex"><computeroutput>Vertex</computeroutput></ulink>
        </listitem>

        <listitem>
          <ulink url="#doxygraph%classEdge"><computeroutput>Edge</computeroutput></ulink>
        </listitem>

        <listitem><ulink url="#doxyaims%classaims_1_1Reader"><computeroutput>Reader&lt;Graph&gt;</computeroutput></ulink>
        </listitem>

        <listitem><ulink url="#doxyaims%classaims_1_1Writer"><computeroutput>Writer&lt;Graph&gt;</computeroutput></ulink>
        </listitem>

        <listitem><ulink url="#doxyaims%classaims_1_1RoiIterator"><computeroutput>RoiIterator</computeroutput></ulink> et dérivées
        </listitem>

        <listitem><ulink url="#doxyaims%classaims_1_1MaskIterator"><computeroutput>MaskIterator</computeroutput></ulink>
        </listitem>

      </itemizedlist>
    </sect2>


    <sect2>
      <title>Manipulation courante</title>

      <sect3>
        <title>Lecture</title>

        <para>Ne pas utiliser les classes bas-niveau dans la lib graph (GraphReader / GraphParser / GraphWriter)
        </para>
        <para>Utiliser les IO génériques d'AIMS:
          <programlisting>#include &lt;aims/io/reader.h&gt;
#include &lt;graph/graph/graph.h&gt;
#include &lt;iostream&gt;

using namespace aims;
using namespace std;

int main( int, char** )
{
  Reader&lt;Graph&gt; reader( "filename.arg" );
  Graph         graph;
  try
  {
    reader.read( graph );
  }
  catch( exception &amp; e )
  {
    cerr &lt;&lt; e.what() &lt;&lt; endl;
  }
}</programlisting>
        </para>
      </sect3>

      <sect3>
        <title>itération sur les noeuds</title>

        <programlisting>  Graph::iterator i, e = graph.end();
  Vertex *v;
  for( i=graph.begin(); i!=e; ++i )
  {
    v = *i;
    // do something with v
  }</programlisting>

        <para>Voir aussi <ulink url="#aims_ex.graphex1.cc">l'exemple 1</ulink>
          <programlisting>
            <textobject>
              <textdata format="txt" fileref="#aims_ex_graphex1.cc">graphex1.cc</textdata>
            </textobject>
          </programlisting>
        </para>
      </sect3>

      <sect3>
        <title>itération sur les relations</title>

        <para>à travers les noeuds:
          <programlisting>  Graph::iterator i, e = graph.end();
  Vertex::iterator ie, ee;
  Vertex *v;
  Edge   *edge;
  for( i=graph.begin(); i!=e; ++i )
  {
    v = *i;
    for( ie=v->begin(), ee=v->end(); ie!=ee; ++ie )
    {
      edge = *ie;
      // do something with edge
    }
  }</programlisting>
        </para>
        <para>illustré aussi dans <ulink url="#aims_ex.graphex1.cc">l'exemple 1</ulink></para>
      </sect3>

      <sect3>
        <title>itération sur les ROI</title>

        <para>Ça se fait en utilisant
          <ulink url="#doxyaims%classaims_1_1RoiIteratorOf_3_01Graph_01_4"><computeroutput>RoiIteratorOf&#060;Graph&#062;</computeroutput></ulink>
          et MaskIterator, des itérateurs "simplifiés" pour les ROIs contenant des buckets.
        </para>
        <para>Apparemment MaskIterator ne fonctionne pas encore sur des graphes sous forme de volumes de labels.
        </para>
        <para>Par contre,
          <ulink url="#doxyaims%classaims_1_1RoiIteratorOf_3_01AimsData_3_01T_01_4_01_4"><computeroutput>RoiIteratorOf&#060;
              AimsData&#060;T&#062; &#062;</computeroutput></ulink> fonctionne sur des volumes. Il manque un petit lien entre les deux...
        </para>
        <para>démonstration dans <ulink url="#aims_ex.graphex2.cc">l'exemple 2</ulink>
        </para>
      </sect3>

      <sect3>
        <title>accès aux objets Aims (maillages, buckets...) dans les graphes</title>

        <para>classe <ulink url="#doxyaims%classaims_1_1GraphManip"><computeroutput>GraphManip</computeroutput></ulink> et structures
          <ulink url="#doxyaims%namespaceaims"><computeroutput>GraphElementTable</computeroutput></ulink>,
          <ulink url="#doxyaims%structaims_1_1GraphElementCode"><computeroutput>GraphElementCode</computeroutput></ulink>
        </para>
        <para>quand on sait ce qu'on y cherche: <ulink url="#aims_ex.graphex3.cc">exemple 3</ulink>
        </para>
        <para>mode exhaustif: <ulink url="#aims_ex.graphex4.cc">exemple 4</ulink>
        </para>
      </sect3>

      <sect3>
        <title>représentation interne: locale ou globale (cf fichiers dans .data)</title>

        <para>locale: 1 fichier par objet</para>
        <para>globale: 1 fichier pour tous les objets de même "identifiant", concaténés en utilisant la dimension temporelle
        </para>
        <para>illustré dans <ulink url="#aims_ex.graphex4.cc">l'exemple 4</ulink> aussi.
        </para>
      </sect3>

      <sect3>
        <title>représentation interne/externe: buckets ou volumes</title>

        <para>Buckets: un bucket par noeud (ou relation), représentation globale ou locale
        </para>
        <para>Volumes: un volume de labels stocké dans le graphe, et un indice dans chaque noeud/relation
        </para>
      </sect3>

      <sect3>
        <title>lecture partielle / écriture</title>

        <para>On utilise le 3ème paramètre (optionnel) de Reader::read() pour dire si on veut lire les objets AIMS
          dans les graphes, et lesquels:
          <screen>  Reader&lt;Graph&gt; reader( "filename.arg" );
  Graph graph;
  reader.read( graph, 0, -1 ); // lit tout (noeuds + relations)
  reader.read( graph, 0, 0 ); // ne lit rien
  reader.read( graph, 0, 1 ); // lit les objets dans les noeuds

  // ou avec les options de lectures plus génériques (système plus moderne):
  Reader&lt;Graph&gt; reader( "filename.arg" );
  Graph graph;
  Object options( new Dictionary );
  options->setProperty( "subobjectsfilter", -1 ); // lit tout, 0: rien, 1: noeuds
  reader.setOptions( options );
  reader.read( graph );</screen>
        </para>
        <para>Écriture: maintenant tous les objets manquants (pas lus) sont lus avant que le graphe soit ré-écrit, de
          manière à ce qu'il ne manque rien.
          <screen>#include &lt;aims/io/writer.h&gt;
// ...
Writer&lt;Graph&gt; writer( "filename.arg" );
writer.write( graph );
          </screen>
        </para>
        <note>
          <para>quand on réécrit un graphe dans son directory d'origine, mais sous un autre nom, le comportement par défaut est de réutiliser le même répertoire <computeroutput>.data</computeroutput> (par mesure d'économie). C'est peut-être une mauvaise idée...
          </para>
          <para>Pour éviter ça, mettre "*" dans la propriété "filename_base" du graphe.
          </para>
        </note>
      </sect3>

    </sect2>


    <sect2>
      <title>Graphes spécialisés (sigraph)</title>

      <para>sillons: FGraph, modèles: MGraph, FRGraph, primal sketches...
      </para>
      <para>Pour lire un graphe spécialisé, normalement il suffit d'utiliser les <computeroutput>Reader</computeroutput> en mode "factory", qui
        renvoient l'objet lu plutôt que d'en remplir un existant:
        <screen>  Reader&#060;Graph&#062; reader( "filename.arg" );
  Graph *graph = reader.read();
  // graph can be a derived graph, like FGraph or FRGraph.</screen>
      </para>
      <para>Il est aussi possible de forcer le type de graphe et d'utiliser l'autre forme de Reader:
        <screen>  Reader&#060;Graph&#062; reader( "filename.arg" );
  FGraph graph;
  reader.read( graph );</screen>
      </para>
    </sect2>


    <sect2>
      <title>Autre utilisation spécialisée: les bundles</title>

      <para>Les "bundles" (faisceaux de fibres) sont stockés sur disque en format (<computeroutput>.bundles</computeroutput>, <computeroutput>.bundlesdata</computeroutput>).
        Ils n'ont pas de structure de donnée propre en mémoire: ce format est fait pour être lu et réécrit à la volée
        (classes <computeroutput>BundleProducer</computeroutput>, <computeroutput>BundleListener</computeroutput> et dérivées).
      </para>
      <para>Ceci dit, ils peuvent aussi être lus sous forme de graphe: c'est ce que fait anatomuist. En principe,
        <computeroutput>Reader&#060;Graph&#062;</computeroutput> sait lire des <computeroutput>.bundles</computeroutput>. On trouve dans les noeuds des graphes de bundles
        des courbes ou des maillages (maillages de segments ou de triangles).
      </para>
    </sect2>


    <sect2>
      <title>En python: pyaims</title>

      <para>exemple dans
        <ulink url="#pyaims_ex.graph_test"><computeroutput>pyaims/examples/graph_test.py</computeroutput></ulink>
      </para>
      <para>Les RoiIterator / MaskIterator n'ont pas encore été exportés en python.</para>
      <para>GraphManip non plus.</para>
    </sect2>


    <sect2>
      <title>Manipulation dans Anatomist</title>

      <para>charger un graphe</para>
      <para>nomenclatures</para>
      <para>visu maillages / buckets</para>
      <para>labels</para>
      <para>modèles, recuit simulé</para>
    </sect2>


    <sect2>
      <title>Futures évolutions, prévues, rêvées, en plan...</title>

      <itemizedlist>
        <listitem>ROI / DOI: lien entre ROIs et des "textures" de données</listitem>
        <listitem>Manipulations plus simples et transparentes pour les objets AIMS dans les graphes (avec des sur-couches
          dans le style RoiIterator / MaskIterator
        </listitem>
        <listitem>Support complet des formats XML et minf</listitem>
        <listitem>Réunion des concepts de graphe et de .minf</listitem>
        <listitem>Prise en compte transparente des référentiels et transformations</listitem>
        <listitem>... ... ... ...</listitem>
      </itemizedlist>
    </sect2>

  </chapter>
</book>

