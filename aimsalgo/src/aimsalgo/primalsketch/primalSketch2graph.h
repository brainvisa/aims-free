/* This software and supporting documentation are distributed by
 *     Institut Federatif de Recherche 49
 *     CEA/NeuroSpin, Batiment 145,
 *     91191 Gif-sur-Yvette cedex
 *     France
 *
 * This software is governed by the CeCILL-B license under
 * French law and abiding by the rules of distribution of free software.
 * You can  use, modify and/or redistribute the software under the
 * terms of the CeCILL-B license as circulated by CEA, CNRS
 * and INRIA at the following URL "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 *
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-B license and that you accept its terms.
 */

#ifndef AIMS_PRIMALSKETCH_PRIMALSKETCH2GRAPH_H
#define AIMS_PRIMALSKETCH_PRIMALSKETCH2GRAPH_H

#include <aims/config/aimsalgo_config.h>
#include <aims/primalsketch/scaleSpaceBlob.h>
#include <aims/primalsketch/scalespace.h>
#include <aims/primalsketch/greyLevelBlob.h>
#include <aims/primalsketch/primalSketch.h>
#include <aims/primalsketch/primalSketchUtil.h>
#include <aims/graph/graphmanip.h>
#include <aims/resampling/motion.h>
#include <graph/graph/graph.h>
#include <aims/bucket/bucket.h>


#include <set>
#include <map>
#include <list>
#include <utility>

using namespace aims;
using namespace std;
using namespace carto;



    struct ltstr_blob // ranking criteria for blobs
    {
        bool operator()(const std::pair<int,float> p1, const std::pair<int,float> p2)
        {
            if (p1.second>p2.second)
                 return true;
            else if (p1.second == p2.second)
            {
                if (p1.first < p2.first)
                    return true;
                else
                    return false;
            }
             else
                return false;
        }
    };

     // class that translates a primalsketch into a graph

     template<typename Geom, typename Text> class Primalsketch2graph
     {
     protected:

          typedef typename SiteType<Geom>::type Site;
          typedef typename TexType<Text>::type Val;

          PrimalSketch<Geom,Text> *_primalSketch;
          Graph     *_graph;
          Motion    *_motion;

          // REM : vertices are scale-space blobs
          //              edges are DIRECTED and represents bifurcation from low scale to high scale
          //              AddEdge(lowScale, highScale, "bifurcation")
          // As a result, one bifurcation can be represented by several edges.

        std::map<int, int> sortedLabels; // map [blob label]->[node ranking] generated by SortBlobs();

     public:

          Primalsketch2graph(PrimalSketch<Geom,Text> *primalSketch) : _primalSketch(primalSketch), _motion( 0 )
              { cout << "construc : " << primalSketch->BifurcationList().size() << endl; _graph=new Graph("PrimalSketchArg");}
          ~Primalsketch2graph()
          {
            delete _motion;
          }
          void setMotion( const Motion & m )
          {
                  if( _motion )
                    delete _motion;
                  _motion = new Motion( m );
                }
          void DoIt();

        void SortBlobs(); //generate a sorted list of blob labels depending on chosen criterion
                            // only max intensity criterion so far, but user's choice later

        Graph *GetGraph(){return _graph;}

     };

     //--------------------------------------------------------------
     // IMPLEMENTATION
     //--------------------------------------------------------------

    template<typename Geom, typename Text>
     void Primalsketch2graph<Geom,Text>::SortBlobs()
    {
        std::list<ScaleSpaceBlob<Site>*> blobList=_primalSketch->BlobSet();
        std::set<std::pair<int, float>,ltstr_blob > labelSet;
        typename std::list<ScaleSpaceBlob<Site>*>::iterator blobIt;
        std::set<std::pair<int, float>,ltstr_blob >::iterator labelIt;
        int label=0;

        std::cout << "Creating blob labels by decreasing maximum intensity" << std::endl;
        for (blobIt=blobList.begin(); blobIt!=blobList.end(); ++blobIt)
        {
            labelSet.insert(std::pair<int,float>((*blobIt)->Label(), (*blobIt)->GetMeasurements().t));
        }
        for (labelIt=labelSet.begin(); labelIt!=labelSet.end(); ++labelIt)
        {
            label++;
            sortedLabels[(*labelIt).first]=label;
        }
    }


    template<typename Geom, typename Text> 
    void Primalsketch2graph<Geom,Text>::DoIt()  {
        std::list<Bifurcation<Site>*> bifList = _primalSketch->BifurcationList();
        std::list<ScaleSpaceBlob<Site>*> blobList = _primalSketch->BlobSet();

        typename std::list<ScaleSpaceBlob<Site>*>::iterator blobIt;
        typename std::list<Bifurcation<Site> *>::iterator bifIt;

        std::map<int, Vertex *> vertMap;

        std::list<ScaleSpaceBlob<Site>*> top, bottom;
        typename std::list<ScaleSpaceBlob<Site>*>::iterator topIt, bottomIt;

        std::string typeAtt;
        Vertex *vert;
        std::string lab;
        char conv[10];
        std::string nameBase = "*";
        int rank;
        SortBlobs();
        _graph->setProperty( "filename_base", "*");
        _graph->setProperty( "subject", _primalSketch->Subject() );

        
        std::string textType;
        if (_primalSketch->Type()==IMAGE)
            textType = "image";
        else if (_primalSketch->Type()==SURFACE)
            textType = "surface";
        else
            textType = "unknown";
        _graph->setProperty( "type", textType );


        blobIt = blobList.begin(); 
//        std::vector<float> tab;
          for ( ; blobIt != blobList.end() ; ++blobIt ) {

               vert =_graph->addVertex( "ssblob" );
               rank = sortedLabels[(*blobIt)->Label()];
               sprintf( conv, "%4i", rank );
               lab = conv;
               vert->setProperty( "label", 0 );
               vert->setProperty( "name", rank+10000 );
               vert->setProperty( "rank", rank );
               vert->setProperty( "index",(*blobIt)->Label() );
               vert->setProperty( "tmin",(*blobIt)->ScaleMin() );
               vert->setProperty( "tmax",(*blobIt)->ScaleMax() );
               vert->setProperty( "trep", (*blobIt)->ScaleRep() );
               vert->setProperty( "lifeTime", (*blobIt)->LifeTime() );               
               vert->setProperty( "maxIntensity",(*blobIt)->GetMeasurements().maxIntensity );
               vert->setProperty( "meanIntensity",(*blobIt)->GetMeasurements().meanIntensity );
               vert->setProperty( "maxContrast",(*blobIt)->GetMeasurements().maxContrast );
               vert->setProperty( "meanContrast",(*blobIt)->GetMeasurements().meanContrast );
               vert->setProperty( "area",(*blobIt)->GetMeasurements().area );
               vert->setProperty( "tValue",(*blobIt)->GetMeasurements().tValue );
               vert->setProperty( "t",(*blobIt)->GetMeasurements().t );
               std::cout << (*blobIt)->GetMeasurements().tValue << ";";
//               moy+=(*blobIt)->GetMeasurements().tValue;
//               tab.push_back((*blobIt)->GetMeasurements().tValue);
               GreyLevelBlobTools<Site> blobTools( (*blobIt)->GlBlobRep() );

               float x1, x2, y1, y2, z1, z2, gx, gy, gz;
               std::vector<float> vectF;
               std::vector<float> triplet(3), ref( 3 );

               vectF = blobTools.Boundingbox();
               x1 = vectF[0]; y1 = vectF[1];  z1 = vectF[2];
               x2 = vectF[3]; y2 = vectF[4];  z2 = vectF[5];
               gx = ( x1 + x2 ) / 2.0; 
               gy = ( y1 + y2 ) / 2.0; 
               gz = ( z1 + z2 ) / 2.0;
               triplet[0] = gx; 
               triplet[1] = gy; 
               triplet[2] = gz;
               triplet = blobTools.Barycenter();
               vert->setProperty("gravity_center", triplet);

                if( _motion )  {
                    Point3df    tal
                      = _motion->transform( Point3df( triplet[0], triplet[1], triplet[2] ) );
                    ref[0] = tal[0];
                    ref[1] = tal[1];
                    ref[2] = tal[2];
                    vert->setProperty( "refgravity_center", ref );
                  }

               triplet[0] = x1;
               triplet[1] = y1; 
               triplet[2] = z1;
               vert->setProperty( "boundingbox_min", triplet );
               triplet[0] = x2;
               triplet[1] = y2;
               triplet[2] = z2;
               vert->setProperty( "boundingbox_max", triplet );
               
               vertMap[(*blobIt)->Label()] = vert;

          }
         

          bifIt = bifList.begin();

          // Adding meshes or buckets
          AddBlobsToPSGraph(_primalSketch, _graph);
     }


#endif
