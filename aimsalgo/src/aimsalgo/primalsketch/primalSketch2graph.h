/*
 *  Copyright (C) 2003-2005 CEA - LSIS
 *
 *  This software and supporting documentation were developed by
 *   Olivier Coulon
 *   Laboratoire LSIS,Groupe LXAO
 *   ESIL, campus de Luminy, Case 925,
 *   13288 Marseille Cedex 29, France
 */

#ifndef AIMS_PRIMALSKETCH_PRIMALSKETCH2GRAPH_H
#define AIMS_PRIMALSKETCH_PRIMALSKETCH2GRAPH_H

#include <aims/config/aimsalgo_config.h>
#include <aims/primalsketch/scaleSpaceBlob.h>
#include <aims/primalsketch/scalespace.h>
#include <aims/primalsketch/greyLevelBlob.h>
#include <aims/primalsketch/primalSketch.h>
#include <aims/primalsketch/primalSketchUtil.h>
#include <aims/graph/graphmanip.h>
#include <aims/resampling/motion.h>
#include <graph/graph/graph.h>
#include <aims/bucket/bucket.h>


#include <set>
#include <map>
#include <list>
#include <utility>

void graphe(vector<float> tab){
  
  vector<uint> votes;
  for (uint i=0;i<100;i++)
    votes.push_back(0);
  float tmin=1000000000000.0,tmax=-1000000000000.0;
  
  for (uint i=0; i<tab.size() ; i++)  {
    float valeur = tab[i];
    if (valeur<tmin) tmin=valeur;
    if (valeur>tmax) tmax=valeur;
  }
  printf("min: %f - max: %f\n", tmin, tmax);
  for (uint i=0; i<tab.size() ; i++)  {
    float valeur = tab[i];
//     printf("%d ", (uint) (((valeur - tmin) / (tmax-tmin))*votes.size()));
    votes[(uint) (((valeur - tmin) / (tmax-tmin))*votes.size())]++;
  }
  printf("\n");
  for (uint i=0;i<100;i++){
    int aux=votes[i];
//     for (uint j=i;j<100;j++){
//       aux += votes[j];
//       
//     }
    printf("%.3f %d\n",tmin+i*(tmax-tmin)/100.0, aux);
  }
  printf("\n");
  
  
}

namespace aims
{

    struct ltstr_blob // ranking criteria for blobs
    {
        bool operator()(const std::pair<int,float> p1, const std::pair<int,float> p2)
        {
            if (p1.second>p2.second)
                 return true;
            else if (p1.second == p2.second)
            {
                if (p1.first < p2.first)
                    return true;
                else
                    return false;
            }
             else
                return false;
        }
    };

     // class that translates a primalsketch into a graph

     template<typename Geom, typename Text> class Primalsketch2graph
     {
     protected:

          typedef typename SiteType<Geom>::type Site;
          typedef typename TexType<Text>::type Val;

          PrimalSketch<Geom,Text> *_primalSketch;
          Graph     *_graph;
          Motion    *_motion;

          // REM : vertices are scale-space blobs
          //              edges are DIRECTED and represents bifurcation from low scale to high scale
          //              AddEdge(lowScale, highScale, "bifurcation")
          // As a result, one bifurcation can be represented by several edges.

        std::map<int, int> sortedLabels; // map [blob label]->[node ranking] generated by SortBlobs();

     public:

          Primalsketch2graph(PrimalSketch<Geom,Text> *primalSketch) : _primalSketch(primalSketch), _motion( 0 )
              { cout << "construc : " << primalSketch->BifurcationList().size() << endl; _graph=new Graph("PrimalSketchArg");}
          ~Primalsketch2graph()
          {
            delete _motion;
          }
          void setMotion( const Motion & m )
          {
                  if( _motion )
                    delete _motion;
                  _motion = new Motion( m );
                }
          void DoIt();

        void SortBlobs(); //generate a sorted list of blob labels depending on chosen criterion
                            // only max intensity criterion so far, but user's choice later

        Graph *GetGraph(){return _graph;}

     };

     //--------------------------------------------------------------
     // IMPLEMENTATION
     //--------------------------------------------------------------

    template<typename Geom, typename Text>
     void Primalsketch2graph<Geom,Text>::SortBlobs()
    {
        std::list<ScaleSpaceBlob<Site>*> blobList=_primalSketch->BlobSet();
        std::set<std::pair<int, float>,ltstr_blob > labelSet;
        typename std::list<ScaleSpaceBlob<Site>*>::iterator blobIt;
        std::set<std::pair<int, float>,ltstr_blob >::iterator labelIt;
        int label=0;

        std::cout << "Creating blob labels by decreasing maximum intensity" << std::endl;
        for (blobIt=blobList.begin(); blobIt!=blobList.end(); ++blobIt)
        {
            labelSet.insert(std::pair<int,float>((*blobIt)->Label(), (*blobIt)->GetMeasurements().t));
        }
        for (labelIt=labelSet.begin(); labelIt!=labelSet.end(); ++labelIt)
        {
            label++;
            sortedLabels[(*labelIt).first]=label;
        }
    }


    template<typename Geom, typename Text>
     void Primalsketch2graph<Geom,Text>::DoIt()
     {
        std::list<Bifurcation<Site>*> bifList=_primalSketch->BifurcationList();
        cout << "testttt : " << bifList.size() << endl;
          std::list<ScaleSpaceBlob<Site>*> blobList=_primalSketch->BlobSet();

        typename std::list<ScaleSpaceBlob<Site>*>::iterator blobIt;
        typename std::list<Bifurcation<Site> *>::iterator bifIt;

        std::map<int, Vertex *> vertMap;

        std::list<ScaleSpaceBlob<Site>*> top, bottom;
        typename std::list<ScaleSpaceBlob<Site>*>::iterator topIt, bottomIt;

        string typeAtt;
        string textType;
        Vertex *vert;
        string lab;
        char conv[10];
          string nameBase="*";
        int rank;

        SortBlobs();
        _graph->setProperty( "filename_base", "*");
        _graph->setProperty("sujet", _primalSketch->Subject());

        if (_primalSketch->Type()==IMAGE)
              textType="image";
        else if (_primalSketch->Type()==SURFACE)
          textType="surface";
        else
          textType="unknown";

        _graph->setProperty("type", textType);


        blobIt=blobList.begin();float moy=0.0;
        vector<float> tab;
          for ( ; blobIt!=blobList.end(); ++blobIt)
          {

               vert=_graph->addVertex("ssblob");
               rank=sortedLabels[(*blobIt)->Label()];
               sprintf(conv, "%4i", rank);
               // This is to label blobs by rank...
               lab = conv;
               //lab="0";
               vert->setProperty("label", 0);
               vert->setProperty("name", rank+10000);
               vert->setProperty("index",(*blobIt)->Label());
               vert->setProperty("tmin",(*blobIt)->ScaleMin());
               vert->setProperty("tmax",(*blobIt)->ScaleMax());
               vert->setProperty("trep", (*blobIt)->ScaleRep());
               vert->setProperty("lifeTime", (*blobIt)->LifeTime());

               vert->setProperty("maxIntensity",(*blobIt)->GetMeasurements().maxIntensity);
               vert->setProperty("meanIntensity",(*blobIt)->GetMeasurements().meanIntensity);
               vert->setProperty("maxContrast",(*blobIt)->GetMeasurements().maxContrast);
               vert->setProperty("meanContrast",(*blobIt)->GetMeasurements().meanContrast);
               vert->setProperty("area",(*blobIt)->GetMeasurements().area);
               vert->setProperty("tValue",(*blobIt)->GetMeasurements().tValue);
               vert->setProperty("t",(*blobIt)->GetMeasurements().t);
               moy+=(*blobIt)->GetMeasurements().tValue;
               tab.push_back((*blobIt)->GetMeasurements().tValue);
               GreyLevelBlobTools<Site> blobTools((*blobIt)->GlBlobRep());

               float x1,x2,y1,y2,z1,z2,gx,gy,gz;
               std::vector<float> vectF;
               std::vector<float> triplet(3), ref( 3 );

               vectF=blobTools.Boundingbox();
               x1=vectF[0]; y1=vectF[1];  z1=vectF[2];
               x2=vectF[3]; y2=vectF[4];  z2=vectF[5];
               gx=(x1+x2)/2.0; gy=(y1+y2)/2.0; gz=(z1+z2)/2.0;
               triplet[0]=gx; triplet[1]=gy; triplet[2]=gz;
               // je change triplet pour les coordonnées du max du glblobrep (comme ça le barycentre utilisé pour les recouvrements dans le recuit devient le max et non plus un barycentre de merde)
               triplet = blobTools.Barycenter();
//                triplet[0]=max[0]; triplet[1]=max[1]; triplet[2]=max[2];
               vert->setProperty("gravity_center", triplet);
               //cout << triplet[0] << ";" << triplet[1] << ";" << triplet[2] << ";"  << (*blobIt)->GetMeasurements().t << endl;

                if( _motion )  {
                    Point3df    tal
                      = _motion->transform( Point3df( triplet[0], triplet[1], triplet[2] ) );
                    ref[0] = tal[0];
                    ref[1] = tal[1];
                    ref[2] = tal[2];
                    vert->setProperty( "refgravity_center", ref );
                  }

               triplet[0]=x1; triplet[1]=y1; triplet[2]=z1;
               vert->setProperty("boundingbox_min",triplet);
               triplet[0]=x2; triplet[1]=y2; triplet[2]=z2;
               vert->setProperty("boundingbox_max",triplet);

               vertMap[(*blobIt)->Label()]=vert;

          }
          moy /= blobList.size();
          cout << "moyenne :" << moy << endl;
          float ecart=0.0;
          for ( blobIt=blobList.begin(); blobIt!=blobList.end(); ++blobIt)
          {
//             vert->setProperty("tValue",(*blobIt)->GetMeasurements().tValue);
            ecart+=pow((*blobIt)->GetMeasurements().tValue-moy,2);
          }

          ecart /=blobList.size();
          cout << "ecart :" << ecart << endl;
          graphe(tab);

          cout << "TEST" << bifList.size() << endl;
          bifIt=bifList.begin();

          // Adding meshes or buckets
//         cout << "test4" << endl;
          AddBlobsToPSGraph(_primalSketch, _graph);
     }
}

#endif
